#include <iostream>
#include <vector>
#include <memory>
#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <thread>
#include <memory>
#include <unistd.h>
#include <sys/syscall.h>

#ifndef SYS_gettid
#error "SYS_gettid unavailable on this system"
#endif

namespace asio = boost::asio;
namespace beast = boost::beast;
using tcp = asio::ip::tcp;
namespace websocket = beast::websocket;
namespace net = boost::asio;
namespace http = beast::http;

class EchoWebsocket : public std::enable_shared_from_this<EchoWebsocket>
{
    websocket::stream<beast::tcp_stream> ws;
    beast::flat_buffer buffer;

public:
    EchoWebsocket(tcp::socket &&socket) : ws(std::move(socket)) {}

    void run()
    {
        ws.async_accept([self{shared_from_this()}](boost::system::error_code ec)
                        {
                            if (ec)
                            {
                                std::cout << "Error in async_accept: " << ec.message() << std::endl;
                                return;
                            }
                            self->echo(); });
    }
    void echo()
    {
        ws.async_read(buffer, [self{shared_from_this()}](beast::error_code ec, std::size_t bytes_tranferred)
                      {
                        std::cout << "thread id " << gettid() << std::endl;
                          if (ec == websocket::error::closed)
                          {
                              std::cout << "Connection closed" << std::endl;
                              return;
                          }
                          if (ec)
                          {
                              std::cout << "Error in async_read_some: " << ec.message() << std::endl;
                              return;
                          }
                          auto out = beast::buffers_to_string(self->buffer.cdata());
                          std::cout << out << std::endl;
                          self->ws.async_write(self->buffer.data(), [self](beast::error_code ec, std::size_t bytes_transferred)
                                               {
                                                   if (ec)
                                                   {
                                                       std::cout << "Error in async_write_some: " << ec.message() << std::endl;
                                                       return;
                                                   }
                                                   self->buffer.consume(bytes_transferred);
                                                   self->echo();
                                               }); });
    }
};

class Listener : public std::enable_shared_from_this<Listener>
{
    net::io_context &ioc;
    tcp::acceptor acceptor;

public:
    Listener(net::io_context &_ioc, unsigned short int port) : ioc(_ioc), acceptor(_ioc, {net::ip::make_address("127.0.0.1"), port}) {}
    void async_Accept()
    {
        acceptor.async_accept(ioc, [self{shared_from_this()}](boost::system::error_code ec, tcp::socket socket)
                              {
                                if(ec)
                                {
                                    std::cout << "Error in async_accept: " << ec.message() << std::endl;
                                    return;
                                }
                                std::make_shared<EchoWebsocket>(std::move(socket))->run();
            std::cout << "New connection" << std::endl;
            self->async_Accept(); });
    }
};

int main()
{
    auto const port = 8083;
    net::io_context ios{};
    std::make_shared<Listener>(ios, port)->async_Accept();
    ios.run();
}